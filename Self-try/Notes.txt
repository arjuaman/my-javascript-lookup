https://123animes.mobi/anime/one-piece/episode/131

web workers can't manipulate dom.
they're like threads from java.

if (
    (Math.abs(circleArray[i].x - shapeBoundingBox.width)<circleArray[i].radius && 
    Math.abs(circleArray[i].x )>shapeBoundingBox.left) 
    &&
    (Math.abs(circleArray[i].y - shapeBoundingBox.height)<circleArray[i].radius && 
    Math.abs(circleArray[i].y )>shapeBoundingBox.top) 
    )
{



import {Circle} from "./Circle.js";
import { ShapeBoundingBox } from "./ShapeBoundingBox.js";

var layer2canvas = document.querySelector('#rockNroad');
var layer2ctx = layer2canvas.getContext('2d');

var xpos = 180;
var ypos = 550;
var speed = 15;

let numRocks = 3;

var road = new Image();
road.src = "https://img.pngio.com/2d-top-down-highway-background-opengameartorg-road-png-top-down-840_650.png";

var spacecraft = new Image();
spacecraft.src = 'images/spacecraftWhite.png';


function move(e){
    if(e.keyCode == 39 || e.keyCode == 68)
        shapeBoundingBox.left+=speed;
    if(e.keyCode == 37 || e.keyCode == 65)
        shapeBoundingBox.left-=speed;
    if(e.keyCode == 38 || e.keyCode == 87)
        shapeBoundingBox.top-=speed;
    if(e.keyCode == 40 || e.keyCode == 83)
        shapeBoundingBox.top+=speed;
}


let shapeBoundingBox = new ShapeBoundingBox(xpos, ypos, 0, 0);
shapeBoundingBox.width = shapeBoundingBox.left + 50;
shapeBoundingBox.height = shapeBoundingBox.top + 50;

function animate() {
    
    requestAnimationFrame(animate);
    document.onkeydown = move;
    layer2ctx.clearRect(0, 0, layer2canvas.width, layer2canvas.height);
    layer2ctx.drawImage(road,0,0,layer2canvas.width,layer2canvas.height);
    layer2ctx.drawImage(spacecraft, shapeBoundingBox.left, shapeBoundingBox.top, 50, 50);
    shapeBoundingBox.width = shapeBoundingBox.left + 50;
    shapeBoundingBox.height = shapeBoundingBox.top + 50;

    // console.log("Spacecraft's: "+shapeBoundingBox.left+" "+shapeBoundingBox.top); 
    // console.log("Spacecraft's dim: "+shapeBoundingBox.width+" "+shapeBoundingBox.height);

    if(shapeBoundingBox.left+50>layer2canvas.width || shapeBoundingBox.left<0)
    {
        alert("You're going off the boundary! Recentering..Recentering..");
        shapeBoundingBox.left = xpos;
        shapeBoundingBox.width = shapeBoundingBox.left + 50;
    }
    if(shapeBoundingBox.top+50>layer2canvas.height || shapeBoundingBox.top<0)
    {
        alert("You're going off the boundary! Recentering..Recentering..");
        shapeBoundingBox.top = ypos;
        shapeBoundingBox.height = shapeBoundingBox.top + 50;
    }

    for(let i=0;i<circleArray.length;i++){
        // document.onkeydown = move;
        circleArray[i].update();

        // console.log("Circle's: " + circleArray[i].x + " " + circleArray[i].y);
        
        //Collision condition:
        if (
            (circleArray[i].x>shapeBoundingBox.left && circleArray[i].x<shapeBoundingBox.width)
            &&
            (circleArray[i].y>shapeBoundingBox.top && circleArray[i].y<shapeBoundingBox.height) 
            )
        {
            
            console.log("Spacecraft's coordinates at collision time:" + shapeBoundingBox.left + " " + shapeBoundingBox.top);
            console.log("Spacecraft's wide coordinates at collision time:" + shapeBoundingBox.width + " " + shapeBoundingBox.height);
            console.log("Circle's coordinates at collision time: " + circleArray[i].x + " " + circleArray[i].y);
            alert("Collision with tip of spacecraft! Sending the culprit ball back to origin. Let's restart!");
            
            circleArray[i].x = 50;
            circleArray[i].y = 50;
            shapeBoundingBox.left = xpos;
            shapeBoundingBox.top = ypos;
            shapeBoundingBox.width = shapeBoundingBox.left + 50;
            shapeBoundingBox.height = shapeBoundingBox.top + 50;
        }

    }
    
}
var circleArray = [];

for (let i = 0; i < numRocks; i++) {
    var radius = 20;
    var x = Math.random() * (layer2canvas.width-2*radius);
    var dx = 0;
    var y = radius;
    var dy = Math.abs(Math.random() - 0.5) * 15;
    circleArray.push(new Circle(x,y,dx,dy,radius));
}

animate()





class MedianFinder {
public:
    priority_queue<int> maxheap;
    priority_queue<int,vector<int>,greater<int>> minheap;
    int tot=0;
    double median;
    //int maxsize=0, minsize=0;
    /** initialize your data structure here. */
    MedianFinder() {
        
    }
    
    void balance(){
        if(abs(maxheap.size()-minheap.size())>1){
            if(maxheap.size()>minheap.size()){
                while(maxheap.size()-minheap.size()>1){
                    int x = maxheap.top();
                    maxheap.pop();
                    minheap.push(x);
                }
            }
            else{
                while(minheap.size()-maxheap.size()>1){
                    int x = minheap.top();
                    minheap.pop();
                    maxheap.push(x);
                }
            }
        }
    }
    
    void addNum(int num) {  
        // int maxsize = maxheap.size();
        // int minsize = minheap.size();
        
        if(tot==0){
            maxheap.push(num);
            //maxheap.size()=1;
            tot++;
            return;
        }
        
        if(num>maxheap.top()){
            minheap.push(num);
        }
        else
            maxheap.push(num);
        
        tot++;
        balance();
    }
    
    double findMedian() {
        if(tot==1){
            cout<<"tot is 1";
            return maxheap.size()>minheap.size()?(double)maxheap.top():(double)minheap.top();
        }
        if(tot%2!=0){
            //odd
            return maxheap.size()>minheap.size()?maxheap.top():minheap.top();
        }
        median = ((double)minheap.top()+maxheap.top())/2;
        return median;
    }
};

/**
 * Your MedianFinder object will be instantiated and called as such:
 * MedianFinder* obj = new MedianFinder();
 * obj->addNum(num);
 * double param_2 = obj->findMedian();
 */